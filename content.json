{"pages":[],"posts":[{"title":"Build a Simple SpringBoot Demo","text":"Integrate SpringBoot with MyBatis. 1 Build a SpringBoot Project1.1 Spring Initializer 1.2 Select what you need 2 Integrate MyBatis123456789101112131415161718server: port: 8081spring: devtools: restart: enabled: true datasource: url: jdbc:mysql://localhost:3306/boot_test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 123456mybatis: type-aliases-package: my.space.demo.pojo mapper-locations: classpath:mapper/*Mapper.xml 分别配置了数据源，和mybatis的类型aliases，以及mapper.xml的映射文件地址。 2.1 Scan Mappers1@MapperScan(value = &quot;my.space.demo.dao&quot;) 2.2 Configurate a mapper Bean1234@Repositorypublic interface UserMapper { List&lt;User&gt; queryAll();} 2.3 Mapper.xml123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;my.space.demo.dao.UserMapper&quot;&gt; &lt;select id=&quot;queryAll&quot; resultType=&quot;user&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 3 JUnit Test12345678910111213@RunWith(SpringRunner.class)@SpringBootTest(classes = DemoApplication.class)public class UserMapperTest { @Autowired private UserMapper userMapper; @Test public void queryAll() throws Exception { List&lt;User&gt; users = userMapper.queryAll(); users.forEach(System.out::println); }} Spring 将Mapper自动装配，装配后直接使用。 4 Final","link":"/2020/11/07/Build-a-Simple-SpringBoot-Demo/"},{"title":"SpringBoot AutoConfiguration","text":"Sth about SpringBoot AutoConfiguraion. 了解自动配置，就需要了解SpringBoot启动类上的注解。 1 $@SpringBootApplication$1234567891011@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication { ...} $@SpringBootConfiguration$ 标注了被标注类是一个组件($@Configuration$) $@EnableAutoConfiguration$ 标注了被标注类开启自动注解。 2 $@EnableAutoConfiguration$123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration { ...} 2.1 $@AutoConfigurationPackage$自动配置包，就是将启动类同级包下的所有组件都添加到容器中去。 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(AutoConfigurationPackages.Registrar.class)public @interface AutoConfigurationPackage { ...} AutoConfigurationPackages.Registrar.class 将自动配置的包，和启动类同级目录下的组件都加入到容器中去。 2.2 $AutoConfigurationImportSelector.class$导入自动配置选择器，将SpringBoot内置的$@Configuration$ 组件加入到容器中，其实就是将配置类应用生效，SpringBoot已经写好了，直接用的默认的配置类。 12345678910111213141516171819public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered { ... protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } AnnotationAttributes attributes = getAttributes(annotationMetadata); List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = getConfigurationClassFilter().filter(configurations); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } ...} getCandidateConfigurations 获取候选的配置类 1234567protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot; + &quot;are using a custom packaging, make sure that file is correct.&quot;); return configurations;} loadFactoryNames: 1234public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) { String factoryTypeName = factoryType.getName(); return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());} 123456789101112131415161718192021222324252627282930private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) { MultiValueMap&lt;String, String&gt; result = cache.get(classLoader); if (result != null) { return result; } try { Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); while (urls.hasMoreElements()) { URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) { String factoryTypeName = ((String) entry.getKey()).trim(); for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) { result.add(factoryTypeName, factoryImplementationName.trim()); } } } cache.put(classLoader, result); return result; } catch (IOException ex) { throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; + FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex); }} 123Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); FACTORIES_RESOURCE_LOCATION 获取默认配置类的位置，使用类加载器加载，映射到Properties返回，loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList())，再取出想要的factoryTypeName。 1FACTORIES_RESOURCE_LOCATION =&gt; META-INF/spring.factories 123456789101112131415loadSpringFactories(classLoader) 返回的 便是SpringBoot默认的配置类包的全限定名&quot;org.springframework.beans.BeanInfoFactory&quot; -&gt; {LinkedList@2090} size = 1&quot;org.springframework.boot.autoconfigure.EnableAutoConfiguration&quot; -&gt; {LinkedList@2092} size = 132&quot;org.springframework.context.ApplicationListener&quot; -&gt; {LinkedList@2094} size = 13&quot;org.springframework.context.ApplicationContextInitializer&quot; -&gt; {LinkedList@2096} size = 8&quot;org.springframework.boot.env.EnvironmentPostProcessor&quot; -&gt; {LinkedList@2098} size = 6&quot;org.springframework.boot.diagnostics.FailureAnalysisReporter&quot; -&gt; {LinkedList@2100} size = 1&quot;org.springframework.boot.diagnostics.FailureAnalyzer&quot; -&gt; {LinkedList@2102} size = 21&quot;org.springframework.boot.SpringBootExceptionReporter&quot; -&gt; {LinkedList@2104} size = 1&quot;org.springframework.boot.SpringApplicationRunListener&quot; -&gt; {LinkedList@2106} size = 1&quot;org.springframework.boot.env.PropertySourceLoader&quot; -&gt; {LinkedList@2108} size = 2&quot;org.springframework.boot.autoconfigure.AutoConfigurationImportListener&quot; -&gt; {LinkedList@2110} size = 1&quot;org.springframework.boot.autoconfigure.AutoConfigurationImportFilter&quot; -&gt; {LinkedList@2112} size = 3&quot;org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider&quot; -&gt; {LinkedList@2114} size = 5 综上，$AutoConfigurationImportSelector.class$ 导入所有SpringBoot默认的配置类","link":"/2020/11/08/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"},{"title":"Usage of yaml in SpringBoot","text":"Use yaml 1 Configurate yaml在$application.yml $中可以配置javabean的属性注入 1234cat: name: abc age: 12 nickName: ccc 2 Java Bean12345678@Component@ConfigurationProperties(prefix = &quot;cat&quot;)public class Cat { private String name; private String nickName; private Integer age; // 注意Bean重要配置GetterAndSetter 否则不能注入} 只有在Spring容器中的Bean才能被注入属性值，所以需要$@Component$ 另外需要$@ConfigurationProperties(prefix = “cat”)$ 声明在yaml文件中的属性前缀。 此时Idea 会提示让你导入一个依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 目的是让application.yml文件中能有提示。 3 @Validated JSR303 校验只有在使用@ConfigurationProperties 注解的时候才能使用使用jsr303校验，即对注入的属性校验格式。 3.1 加入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 3.2 Validated在Bean前加入$@Validated$ 注解，就可以在属性上加校验了，比如$@Email$ ,$@NotNull$ 当输入不符合规范的时候 Binding to target org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under ‘cat’ to my.space.demo.pojo.Cat failed: Property: cat.nameValue: lzzOrigin: class path resource [application.yaml]:20:9Reason: 不是一个合法的电子邮件地址 4 @Value 注入使用@Value 和SPEL表达式也可以注入，但是不支持松散绑定，即不能自动转换驼峰命名法。 12345678@Component//@ConfigurationProperties(prefix = &quot;cat&quot;)public class Cat { @Value(value = &quot;${cat.name}&quot;) private String name; private String nickName; private Integer age;} 5 对比 @Value @ConfigurationProperties 单个属性赋值 批量复制 不支持松散绑定 支持松散绑定 不支持JSR303校验 支持校验 支持SpEL 不支持Spring表达式语言 6 占位符可以使用$${}$ 获取配置文件上下文的内容，如果不存在，可以使用冒号指定默认值 12cat: name: ${dog.name:lzz}_01","link":"/2020/11/08/Usage-of-yaml-in-SpringBoot/"},{"title":"PropertiesSource And ImportResource Annotation","text":"@PropertiesSource 被用来导入指定的yaml配置文件，@ImportResource 被用来导入指定的xml的配置文件(比如bean的注入) 1 @PropertiesSource将配置从application.yml中分离出来，然后使用PropertiesSource读取配置，注意要用properties文件 123cat.age=12cat.name=lzzcat.nick-name=lzq 12345678@Component@PropertySource(value = &quot;classpath:application-cat.properties&quot;)@ConfigurationProperties(prefix = &quot;cat&quot;)public class Cat { private String name; private String nickName; private Integer age;} Tips: 建议所有的配置文件都以application开头，这样会被idea识别为SpringBoot的配置文件，会有代码提示 2 @ImportResource之前在Spring中所有的Bean注入都是在xml中完成的，SpringBoot也可以这样做，虽然不推荐。 在启动类中添加这个注解，value值写入类路径下的xml文件即可，不推荐 3 推荐的SpringBoot配置的写法使用配置类，新建包config，在这里面写配置类 1234567@Configurationpublic class MyAppConfiguration { @Bean public Dog tinyDog() { return new Dog(); }} Dog类中没有添加@Component注解，但是仍然注入成功，bean名就是tinyDog。","link":"/2020/11/08/PropertiesSource-And-ImportResource/"},{"title":"SpringBoot AutoConfiguration","text":"Principle of AutoConfiguration. 1 @EnableAutoConfiguraion​ 开启自动配置 2 @Import(AutoConfigurationImportSelector.class)​ 导入自动配置选择器，具体导入了什么，查看$AutoConfigurationImportSelector$ 中的selectImports -&gt; getAutoConfigurationEntry 方法。 3 getAutoConfigurationEntry1234567891011121314protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } AnnotationAttributes attributes = getAttributes(annotationMetadata); List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = getConfigurationClassFilter().filter(configurations); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions);} 1List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); ​ 获取候选的配置 12345protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); ...} 123protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() { return EnableAutoConfiguration.class;} 123456789101112131415161718private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) { ... Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); while (urls.hasMoreElements()) { URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) { String factoryTypeName = ((String) entry.getKey()).trim(); for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) { result.add(factoryTypeName, factoryImplementationName.trim()); } } ...} 调用 $SpringFactoriesLoader.loadFactoryNames() $ 使用类加载器获取资源$FACTORIES_RESOURCE_LOCATION $ ( “META-INF/spring.factories” ) ，扫描所有jar包下的这个文件里的内容，整理成properties，返回所有的自动配置类，再从这些里面获取 $ EnableAutoConfiguration.class $ 对应的值。 META-INF/spring.factories在包$spring-boot-autoconfigure-2.3.5.RELEASE.jar$ 里面可以找到含有EnableAutoConfiguration属性的properties，对应的值便是候选的自动配置类（getAutoConfigurationEntry ）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\org.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration 以 HttpEncodingAutoConfiguration 为例解释自动配置原理12345678@Configuration(proxyBeanMethods = false) // 表示当前类为配置类，可加入到容器中@EnableConfigurationProperties(ServerProperties.class) // 开启ConfigurationProperties@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)@ConditionalOnClass(CharacterEncodingFilter.class)@ConditionalOnProperty(prefix = &quot;server.servlet.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true)public class HttpEncodingAutoConfiguration { ...} ServerProperties.class1234@ConfigurationProperties(prefix = &quot;server&quot;, ignoreUnknownFields = true)public class ServerProperties { ...} 这个类的属性可以从properties文件中注入，书写格式的前缀便是”server” 因此，在application.yml 文件中配置的所有的属性，都可以找到一个xxxxProperties配置类作为依据，类中所有的属性便可以配置的属性。 @EnableConfigurationProperties便将properties文件和配置类绑定 @ConditionalOnXXXX作为一种条件判断的注解。 比如：$@ConditionalOnWebApplication$ 注解便是判断当前是不是一个web应用。 $@ConditionalOnClass$ 判断当前是否已经有过滤器$CharacterEncodingFilter$ $@ConditionalOnProperty$ 判断当前是否有该properties属性，如果没有就设置为 true，然后再判断，其实就是永远为真，无论你写不写这个properties键。 配置类的书写12345678910111213141516171819202122232425@Configuration(proxyBeanMethods = false)@EnableConfigurationProperties(ServerProperties.class)@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)@ConditionalOnClass(CharacterEncodingFilter.class)@ConditionalOnProperty(prefix = &quot;server.servlet.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true)public class HttpEncodingAutoConfiguration { private final Encoding properties; // 将配置的properties属性注入到该配置类中 public HttpEncodingAutoConfiguration(ServerProperties properties) { this.properties = properties.getServlet().getEncoding(); } @Bean @ConditionalOnMissingBean // 在容器中缺失该bean的时候注入到容器中。注入组件的依赖，属性值则从properties文件中获取 public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Encoding.Type.RESPONSE)); return filter; } ...} 原理SpringBoot 自动配置的基本原理，就是SpringBoot已经提前写好了很多配置类，在工程启动的时候会根据情况将需要的自动配置类加入到容器中，这些配置类又和properties 文件绑定，从properties文件中配置便可以注入到自动配置类中，自动配置类又根据配置new出依赖加入到容器中。","link":"/2020/11/08/SpringBoot-AutoConfiguration/"},{"title":"SpringBoot Logging Framework","text":"Logging Logging Logging… 1.1 SpringBoot Logging FrameworkSpringBoot推荐日志框架抽象层使用slf4j，实现层使用Logback，但是也可以使用其他的日志框架，比如JUL，可以在中间添加适配层（slf4j开头的jar包），实现slf4j接口，调用JUL的方法。 1.2 遗留问题在将各种框架整合在一起的时候，不同的框架使用不同的日志实现，如何统一？ SLF4J 官方让使用xxx-over-slf4j.jar提换掉原来的实现jar，从而实现使用原来的接口（比如log4j，以保证其他框架正常使用）但是事实上调用logback的实现类。 根据maven依赖可知，logback直接依赖于slf4j-api，而其他框架依赖于xxx-to-slf4j，然后再简介依赖slf4j 2.1 SpringBoot 使用日志123456789@RunWith(SpringRunner.class)@SpringBootTestpublic class LoggingTest { @Test public void logTest() { Logger logger = LoggerFactory.getLogger(LoggingTest.class); logger.warn(&quot;wuhu qifei~&quot;); }} 2.2 SpringBoot日志配置1234logging: level: trace path: 输出日志文件路径 file: 输出日志文件名字 3.1 日志框架替换假设现在想使用log4j，那么就需要先将log4j-to-slf4j替换掉，因为本身就是用log4j嘛 12345678910111213141516171819202122 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt;&lt;/dependency&gt;","link":"/2020/11/11/SpringBoot-Logging-Framework/"},{"title":"SpringBoot WebAutoConfiguration","text":"WebAutoConfiguration SpringBoot 对SpringMVC的自动配置均在WebAutoConfiguration中。 1 Static Resource12345678910111213141516171819202122232425262728@Configuration(proxyBeanMethods = false)@Import(EnableWebMvcConfiguration.class)@EnableConfigurationProperties({ WebMvcProperties.class, ResourceProperties.class })@Order(0)public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer { ... @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { logger.debug(&quot;Default resource handling disabled&quot;); return; } Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) { customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); } String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) { customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); } } ...} 在WebAutoConfiguration中可以找到静态内部类WebMvcAutoConfigurationAdapter，在方法addResourceHandlers中可以看到SpringBoot对静态资源的配置分为两种，一种是webjars的配置，一种是对静态资源目录下的配置。 1.1 webjars使用maven也可以配置常见的web静态资源，如js，css等 在https://www.webjars.org/可以找到相应的maven依赖 将包导入后，SpringBoot会在类路径下找到webjars文件夹，将webjars连同里面的资源一起导入到类路径下，从而方便获取。 1&lt;script src=&quot;../static/js/static_src.js&quot; th:src=&quot;@{/webjars/jquery/3.5.1/jquery.js}&quot;&gt;&lt;/script&gt; 注意：在Thymeleaf中，在前面加/ 表示从网站根目录下开始请求，不加表示在当前访问路径下请求 1.2 static resource path1this.resourceProperties.getStaticLocations() 1234567891011public class ResourceProperties { private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; }; /** * Locations of static resources. Defaults to classpath:[/META-INF/resources/, * /resources/, /static/, /public/]. */ private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;} 可以看出默认配置的资源路径为这些 Unfinished","link":"/2020/11/11/SpringBoot-WebAutoConfiguration/"},{"title":"Linear Algebra Review 1","text":"Linear Algebra and Its Applications Chapter 1. 1.1 线性方程组1.1.1 等价如果两个线性方程组有相同的解集，那么就称两个线性方程组等价。 1.1.2 解的情况 线性方程组解集的三种情况： 无解 有唯一解 有无穷多解 特殊的，称线性方程组有唯一或者无穷多个解为线性方程组相容。，若无解，则称为不相容。 1.1.3 增广矩阵$$[\\alpha_1, \\alpha_2, \\alpha_3…\\alpha_n]x=\\beta$$ $$[\\alpha_1, \\alpha_2, \\alpha_3…\\alpha_n, \\beta]$$ 1.1.4 方程组的解法1.1.4.1 初等行变换 倍加变换 对换变换 倍乘变换 若一个矩阵通过初等行变换变为另一个矩阵，则称这两个矩阵行等价。 1.1.5 解的存在性和唯一性 初步可以使用初等行变换，变为阶梯矩阵，如果在增广矩阵中某一行$A$某一行变为0，$\\beta$不为零，则不满足。$$ \\left[ \\begin{matrix} \\alpha_{11} &amp; \\alpha_{11} &amp; \\alpha_{11} &amp; \\beta_1\\ 0 &amp; \\alpha_{11} &amp; \\alpha_{11} &amp; \\beta_2\\ 0 &amp; 0 &amp; 0 &amp; \\beta_3 \\end{matrix} \\right]$$ 1.2 行化简与阶梯形矩阵1.2.1 先导元素 非零行的先导元素是指该行中最左边的非零元素。 1.2.2 简化阶梯形矩阵 每一个矩阵行等价与唯一的一个简化行阶梯矩阵 简化阶梯形矩阵的先导元素必为1 1.2.3 主元位置 / 主元列 定义 矩阵中的主元位置是A中对应于它的阶梯形中先导元素的位置，主元列是A的含有主元位置的列。 Unfinished","link":"/2020/11/15/Linear-Algebra-Review-1/"},{"title":"Linear Regression","text":"The implement of Linear Regression with Pytorch. 1 公式线性预测函数：$${\\hat y} = wx+b$$损失函数：$$loss = {1 \\over 2} \\sum_i {(y_i-{\\hat y}_i)^2}$$梯度下降就好了 2 Pytorch实现2.1 真实预测函数12def real_function(x): return 10 * x + 5 2.2 生成随机数据1234def gen_data(count, batch_size): x = torch.randn(batch_size, count, 1) y = real_function(x) + torch.randn(count, 1) return x, y 2.3 模型定义12345678class LinearRegression(nn.Module): def __init__(self): super(LinearRegression, self).__init__() self.fc = nn.Linear(1, 1, bias=True) self.activation = nn.Sigmoid() def forward(self, x): return self.fc(x) 2.4 训练12345678910111213141516171819def train(train_x, train_y, test_x, test_y, model: nn.Module, epochs: int): optimizer = torch.optim.SGD(model.parameters(), lr=0.005) loss_function = torch.nn.MSELoss() for epoch in range(epochs): for i, x in enumerate(train_x): y_pred = model(x) loss = loss_function(y_pred, train_y[i]) optimizer.zero_grad() loss.backward() optimizer.step() if i % 20 == 0: print(loss.item()) model.eval() y_pred = model(x_test) save_processing(test_x, test_y, y_pred.detach().numpy(), str(epoch) + '.jpg') model.train() 2.5 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import torchimport torch.nn as nnimport torchvisionimport torchvision.transforms as transformsimport numpy as npimport matplotlib.pyplot as pltfrom PIL import Imageimport imageioimport osdef real_function(x): return 10 * x + 5def show_grid(x, y): plt.scatter(x.squeeze(), y.squeeze()) plt.show()def show_test_pred_grid(x, y, pred_y): plt.scatter(x.squeeze(), y.squeeze()) plt.scatter(x.squeeze(), pred_y.squeeze()) plt.show()def save_processing(x, y, pred_y, filename): plt.clf() plt.scatter(x.squeeze(), y.squeeze(), s=12, c='red') plt.scatter(x.squeeze(), pred_y.squeeze(), s=12, c='blue') plt.savefig(filename)def create_gif(): def inner_cmp(elem: str): return int(elem[:elem.find('.')]) imgs_names = [file for file in os.listdir() if file.endswith('jpg')] imgs_names = sorted(imgs_names, key=lambda elem: inner_cmp(elem)) print(imgs_names) frame = [] for filename in imgs_names: frame.append(imageio.imread(filename)) imageio.mimsave('processing.gif', frame, 'GIF', duration=0.35)def gen_data(count, batch_size): x = torch.randn(batch_size, count, 1) y = real_function(x) + torch.randn(count, 1) return x, yclass LinearRegression(nn.Module): def __init__(self): super(LinearRegression, self).__init__() self.fc = nn.Linear(1, 1, bias=True) self.activation = nn.Sigmoid() def forward(self, x): return self.fc(x)def train(train_x, train_y, test_x, test_y, model: nn.Module, epochs: int): optimizer = torch.optim.SGD(model.parameters(), lr=0.005) loss_function = torch.nn.MSELoss() for epoch in range(epochs): for i, x in enumerate(train_x): y_pred = model(x) loss = loss_function(y_pred, train_y[i]) optimizer.zero_grad() loss.backward() optimizer.step() if i % 20 == 0: print(loss.item()) model.eval() y_pred = model(x_test) save_processing(test_x, test_y, y_pred.detach().numpy(), str(epoch) + '.jpg') model.train() create_gif()if __name__ == '__main__': x_train, y_train = gen_data(50, 10) x_test, y_test = gen_data(50, 1) # show_grid(x_train, y_train) model = LinearRegression() for param in model.parameters(): torch.nn.init.normal(param) train(x_train, y_train, x_test, y_test, model, 20) # show_test_pred_grid(x_test, y_test, y_pred.detach().numpy()) 3 数据可视化3.1 绘制预测值和真实值12345678910def show_test_pred_grid(x, y, pred_y): plt.scatter(x.squeeze(), y.squeeze()) plt.scatter(x.squeeze(), pred_y.squeeze()) plt.show()def save_processing(x, y, pred_y, filename): plt.clf() plt.scatter(x.squeeze(), y.squeeze(), s=12, c='red') plt.scatter(x.squeeze(), pred_y.squeeze(), s=12, c='blue') plt.savefig(filename) 3.2 创建GIF1234567891011def create_gif(): def inner_cmp(elem: str): return int(elem[:elem.find('.')]) imgs_names = [file for file in os.listdir() if file.endswith('jpg')] imgs_names = sorted(imgs_names, key=lambda elem: inner_cmp(elem)) print(imgs_names) frame = [] for filename in imgs_names: frame.append(imageio.imread(filename)) imageio.mimsave('processing.gif', frame, 'GIF', duration=0.35) 将每一帧的图片放入列表中，传入$mimsave$ 中。","link":"/2020/11/27/Linear-Regression/"},{"title":"Something about Entropy","text":"KL Divergence, Cross Entropy, CELoss, BELoss 信息量$$I(x)=-log(p(x)) \\quad x \\in X$$ 某事件发生的概率越大，那么信息量越小 熵$$H(X)=-\\sum_{x \\in X}p(x)log(p(x))$$ $X$ 表示某一事件的随机变量，$x$表示随机变量$X$所有可能的取值情况。比如，事件$X$表示骰子的显示点数，那么$x\\in{1,2,3,4,5,6}$。 熵就是对随机变量X不确定性的度量，即对$X$所有取值的信息量的期望。 相对熵 / KL 散度$$D_{KL}(p||q)=\\sum_{x\\in X}p(x)log{p(x) \\over q(x)}= \\sum_{x\\in X}p(x)log(p(x)) -\\sum_{x\\in X}p(x)log(q(x))$$ 表示两个随机变量分布的距离（但是KL散度不具有对称性，$D_{KL}(p||q)\\neq D_{KL}(q||p)$） 如果$D_{KL}(p||q)=0$表示分布完全相同 这里的$p, q$表示对于统一随机事件的不同概率分布，就好比都是掷骰子，但是$p$分布下每个点数出现的概率和$q$分布不同。 交叉熵$$H(p,q)=\\sum_{x\\in X}p(x)log{1 \\over q(x)}= -\\sum_{x\\in X}p(x)log(q(x))$$ 发现交叉熵和$D_{KL}(p||q)$相差一个$H(p)$$$\\begin{aligned}H(p) &amp;=-\\sum_{x\\in X} p\\left(x\\right) \\log p\\left(x\\right) \\\\D_{K L}(p | q) &amp;=\\sum_{x \\in X} p\\left(x\\right) \\log \\frac{p\\left(x\\right)}{q\\left(x\\right)}=\\sum_{x\\in X}\\left(p\\left(x\\right) \\log p\\left(x\\right)-p\\left(x\\right) \\log q\\left(x\\right)\\right.\\\\H(p, q) &amp;=-\\sum_{x\\in X} p\\left(x\\right) \\log q\\left(x\\right)\\\\\\end{aligned}$$对于给定$N$个样本，其$H(p) \\quad p\\sim real$ 是一个常数。 交叉熵损失函数如何计算的损失函数$$H(p, q) =-\\sum_{x\\in X} p\\left(x\\right) \\log q\\left(x\\right)=-\\mathbb {E}(\\log q(x))$$ 注意，此处$\\Sigma$ 的对象是随机变量$X$的取值，所以上是可以写为：$$H(p, q)=-\\left[ p(x_1)\\log q\\left(x_1\\right) +p(x_2)\\log p(x_2) + p(x_3)\\log q(x_3)+ \\dots+p(x_n)\\log q(x_n) \\right] \\\\x_1,x_2,x_3,\\dots, x_n \\in X$$因为给定$M$个样本，所以我们可以用频率代替概率：$$\\begin{equation}H(p, q)=-\\left[ {count(x_1) \\over M} \\log q\\left(x_1\\right) +{count(x_2) \\over M}\\log p(x_2) + {count(x_3) \\over M}\\log q(x_3)+ \\dots+{count(x_n) \\over M}\\log q(x_n) \\right] \\\\x_1,x_2,x_3,\\dots, x_n \\in X \\\\\\sum_{i}^{N}count(x_i)=M \\\\\\end{equation}$$注意，$N$表示随机变量$X$有N种取值，$M$表示一共有M个样本，$count(x_i)$表示随机变量$x_i$在这M个样本中出现的次数。（注意区分$\\Sigma$ 求和的对象）因此，上式可以写作：$$H(p, q)=-{1\\over M}\\sum_{i}^{N}\\left[ count(x_i) \\log q(x_i) \\right]$$上式可以解释为，给定$M$个样本，我可以算出这些样本中不同“类别”各有多少个样本，分别和我的模型预测的该类别的概率相乘即为交叉熵。但是，事实上，我们不会先算样本里不同类别有多少，而是按照一个样本一个样本的算。 因此：$$H(p, q)=-{1 \\over M}\\sum_i^N\\sum_j^M[\\mathbb I(x^{(j)}=i)\\log q(x_i^j)]$$此式表示对于给定的某一类别$x_i$，我将模型对$M$个样本的预测中，预测为类别$i$的，就将$\\log q(x_i^j)$加到$H(p, q)$中去。 此处的$\\mathbb I(x^{(j)}=i)$表示，如果第$j$个样本的真实类别是$i$那么返回值就是$1$，否则为$0$。 也可以看作是，对于样本$x$ ，他的真实类别是 更加形象一点：$$\\begin{aligned}H(p, q)&amp;=-{1 \\over M}\\sum_{i}^{N}\\left[ count(x_i) \\log q(x_i) \\right] \\\\H(p, q)&amp;=-{1 \\over M}\\sum_i^N\\sum_j^M[\\mathbb I(x^{(j)}=i)\\log q(x_i^j)] \\\\H(p, q)&amp;=-{1 \\over M}\\sum_j^{M}\\left[ \\mathbb I(x^{(j)}= k)(0_{i=0} * \\log q(x^{(j)}) +0_{i=1} * \\log q(x^{(j)})+\\dots+1_{i=k} * \\log q(x^{(j)})) + \\dots +0_{i=n}*\\log q(x^{(j)})\\right] \\\\\\end{aligned}$$综上，可以阐述交叉熵函数的计算原理，即对于$M$个样本，将模型预测出的总共$N$个类别的概率中，将第$k$个类别的概率加入损失函数中，其中$k$的取值即为真实label的值。 二分类的交叉熵损失函数 BCELoss如果写作概率的表达形式$$H(p, q)=-\\left[ p(x=1)\\log q(x=1) + p(x=0)\\log q(x=0) \\right]$$写作对样本求和的形式：$$H(p, q) = -\\sum_i^M\\left[ y^{i} \\log q(x^{(i)}) + (1-y^{i})\\log (1-q(x^{(i)})) \\right]$$ Pytorch 中的CrossEntropyLossShape: Input: (N, C)(N,C) where C = number of classes, or (N, C, d_1, d_2, …, d_K)(N,C,d1,d2,…,dK) with K \\geq 1K≥1 in the case of K-dimensional loss. Target: (N)(N) where each value is$ 0 \\leq \\text{targets}[i] \\leq C-10≤targets[i]≤C−1 , or (N, d_1, d_2, …, d_K)(N,d1,d2,…,dK)$ with$ K \\geq 1K≥1 $in the case of K-dimensional loss. Output: scalar. If reduction is 'none', then the same size as the target: $(N) , or (N, d_1, d_2, …, d_K)(N,d1,d2,…,dK)$ with$ K \\geq 1K≥1 $in the case of K-dimensional loss. Pytroch target就是一个整数，如果有$K$类，那么每一类编号$[0, K-1]$","link":"/2020/11/27/Something-about-Entropy/"},{"title":"Logistic Regression","text":"The implement of Logistic Regression Logistic Regression简单理解使用一超平面划分$A, B$两类，分为正类和负类，将某一坐标值带入后可以根据结果的正负判断分类。 使$Sigmoid$ 函数表示概率，得出最大似然估计$$loss = -{1 \\over m}\\sum_i{[y^{(i)}log(h(x^{(i)})) + (1-y^{(i)})log(1-h(x^{(i)}))]}$$优化即可，最终的决策边界为一条直线，分开正类和负类，如果对于线性不可分，将$h(x)$替换为非线性函数即可（即多层感知机）。 代码1234567891011class LogisticRegression(nn.Module): def __init__(self): super(LogisticRegression, self).__init__() self.fc = nn.Linear(2, 1, bias=True) self.activation = torch.nn.Sigmoid() def forward(self, x): # print('in forward:', x.size(), self.fc.weight.size()) return self.activation(self.fc(x)) 如果使用多层感知机，参数初始换使用标准正态分布比较好，对于均匀分布学的的决策边界很容易成为线性的。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136import torchimport torch.nn as nnimport torchvisionimport torchvision.transforms as transformsimport numpy as npimport matplotlib.pyplot as pltdef real_function(x): return torch.sqrt(0.25 - (x - 0.5) ** 2)def gen_data(count, batch_size): x = torch.rand(count, batch_size, 1, 2) y = torch.zeros(count, batch_size, 1, 1, requires_grad=False) for c in range(count): for batch in range(batch_size): x1 = x[c][batch][0][0] x2 = x[c][batch][0][1] if x2 &gt; real_function(x1): y[c][batch][0][0] = 1 return x, yclass LogisticRegression(nn.Module): def __init__(self): super(LogisticRegression, self).__init__() self.fc1 = nn.Linear(2, 8, bias=True) self.fc2 = nn.Linear(8, 4, bias=True) self.fc3 = nn.Linear(4, 1, bias=True) self.tanh = nn.Tanh() self.sigmoid = nn.Sigmoid() def forward(self, x): # print('in forward:', x.size(), self.fc.weight.size()) x = self.fc1(x) x = self.sigmoid(x) x = self.fc2(x) x = self.sigmoid(x) x = self.fc3(x) return self.sigmoid(x)def train(x_train, y_train, x_test, y_test, model: nn.Module, epochs): optimizer = torch.optim.Adam(model.parameters(), lr=0.002, weight_decay=1e-5) loss_function = nn.BCELoss() for epoch in range(epochs): for i, x in enumerate(x_train): y_pred = model(x) # 前者是input，后者是target # 前者需要梯度，后者不需要梯度 loss = loss_function(input=y_pred, target=y_train[i]) optimizer.zero_grad() loss.backward() optimizer.step() if i % 100 == 0: print(loss.item())def test(x_test, y_test, model: nn.Module): model.eval() cnt = 0 for i, x in enumerate(x_test): y_pred = model(x) # print(x.size(), y_pred.size()) y_pred.detach()[y_pred &gt;= 0.5] = 1 y_pred.detach()[y_pred &lt; 0.5] = 0 result = (y_pred == y_test[i]) cnt += result.sum().item() print('accuracy = ' + str(100.0 * cnt / (x_test.size()[0] * x_test.size()[1])) + '%')def show_grid(model: nn.Module): batch_size = 10 x_data, _ = gen_data(500, batch_size) model.eval() plt.xlim((0, 1)) plt.ylim((0, 1)) for i, x in enumerate(x_data): y_pred = model(x) for c in range(batch_size): if np.abs(y_pred[c][0][0].item() - 0.5) &lt; 0.1: # print(y_pred[c][0][0].item() - 0.5) plt.scatter(x[c][0][0], x[c][0][1], c='blue')def show_origin(x_data, y_data, batch_size): plt.xlim((0, 1)) plt.ylim((0, 1)) for i, x in enumerate(x_data): for c in range(batch_size): if y_data[i][c][0][0].item() == 1: plt.scatter(x[c][0][0], x[c][0][1], c='red') else: plt.scatter(x[c][0][0], x[c][0][1], c='black')if __name__ == '__main__': x_train, y_train = gen_data(100, 10) x_test, y_test = gen_data(100, 10) model = LogisticRegression() # 使用正态分布初始化参数，对使用sigmoid激活函数的多层神经网络做二分类有帮助 # 使用均匀分布最终的判别边界会变成一条直线? # for param in model.parameters(): # torch.nn.init.uniform(param) for param in model.parameters(): torch.nn.init.normal(param) train(x_train, y_train, x_test, y_test, model, 150) # model.load_state_dict(torch.load('./params.pkl')) test(x_test, y_test, model) show_origin(x_train, y_train, 10) show_grid(model) plt.savefig('result.jpg') plt.show() torch.save(model.state_dict(), 'params.pkl') # for param in model.parameters(): # print(param)","link":"/2020/11/27/Logistic-Regression/"},{"title":"Conv And ConvTranspose Pooling And Unpooling","text":"To be honest, I don’t really the meaning behind these formulas. Conv2d$$H_{out} = \\left \\lfloor {\\\\{H_{in} + 2 * padding - kernel\\_size} \\over stride } + 1 \\right \\rfloor$$ ConvTranspose2d$$H_{out} = (H_{in} - 1) * stride - 2 * padding + dilation * (kernel_size - 1) + output_padding + 1$$ $dalition$ 默认为1，$output_padding$默认为0 或者：$$H_{out} = (H_{in} - 1) * stride - 2 * padding + kernel\\_size$$ MaxPool2d$$H_{out} = H_{Conv_out}$$ MaxUnpool2d如果需要反池化，需要在层加参数$return_indices=True$，将返回的$indices$传入到$MaxUnpool2d$中$$H_{out} = (H_{in} - 1) * stride - 2 * padding + kernel\\_size$$有点麻烦，不好编程 AutoEncoder123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Encoder(nn.Module): def __init__(self): super(Encoder, self).__init__() self.conv2d_1 = nn.Conv2d(1, 8, kernel_size=5, stride=2, padding=1) self.conv2d_2 = nn.Conv2d(8, 16, kernel_size=3, stride=2, padding=1) self.batch_1 = nn.BatchNorm2d(8) self.batch_2 = nn.BatchNorm2d(16) self.max_pool2d = nn.MaxPool2d(kernel_size=2, stride=2, padding=0, return_indices=True) self.relu = nn.ReLU() def forward(self, x): x = self.conv2d_1(x) x = self.batch_1(x) x = self.relu(x) x, indices_1 = self.max_pool2d(x) x = self.conv2d_2(x) x = self.batch_2(x) x = self.relu(x) x, indices_2 = self.max_pool2d(x) return x, indices_1, indices_2class Decoder(nn.Module): def __init__(self): super(Decoder, self).__init__() self.de_conv_2 = nn.ConvTranspose2d(in_channels=16, out_channels=8, kernel_size=4, stride=2, padding=1) self.de_conv_1 = nn.ConvTranspose2d(in_channels=8, out_channels=1, kernel_size=6, stride=2, padding=1) self.un_pool_2 = nn.MaxUnpool2d(kernel_size=3, stride=1, padding=0) self.un_pool_1 = nn.MaxUnpool2d(kernel_size=3, stride=2, padding=0) self.batch_2 = nn.BatchNorm2d(8) self.batch_1 = nn.BatchNorm2d(1) self.relu = nn.ReLU() self.tanh = nn.Tanh() def forward(self, x, indices_1, indices_2): x = self.un_pool_2(x, indices_2) x = self.de_conv_2(x) x = self.batch_2(x) x = self.relu(x) x = self.un_pool_1(x, indices_1) x = self.de_conv_1(x) x = self.batch_1(x) x = self.tanh(x) return xclass AutoEncoder(nn.Module): def __init__(self): super(AutoEncoder, self).__init__() self.encoder = Encoder() self.decoder = Decoder() def forward(self, x): code, indices_1, indices_2 = self.encoder(x) result = self.decoder(code, indices_1, indices_2) return result","link":"/2020/11/28/Conv-And-ConvTranspose-Pooling-And-UnPooling/"},{"title":"Diary 12-01-2020","text":"至舍，四肢僵竟不能动。 这周事情有点多，做实验，体测，离散考试，答辩。。 近期情绪稳定，也都还好。 看了写GAN, 写了几个GAN，下周开始研究CycleGAN吧，这周看CGAN。 找到汉字数据了 没啥了。","link":"/2020/12/01/Diary-12-01-2020/"},{"title":"Happy Birthday~","text":"Happy birthday to me ~","link":"/2020/12/05/Happy-Birthday/"},{"title":"Diary-12-14-2020","text":"起风了，很大。 气温很低，我也许该换衣服了。 考完四级了，一般般吧，有种高考考完英语的感觉。 这周做数字电路的课程设计，还有口语考试，六篇目前背了两篇（；´д｀）ゞ 起风了。","link":"/2020/12/14/Diary-12-14-2020/"},{"title":"Diary-12-25-2020","text":"惶惶不可终日，怏怏何须一生 今天大概是近时间以来心情最差的一天吧。 烦躁，无所事事。 害怕。","link":"/2020/12/25/Diary-12-25-2020/"},{"title":"Something about Pointers","text":"指针啊指针啊 1 指针数组与数组指针1.1 指针数组就是一个数组，只不过存储的数据都是指针。 1.2 数组指针指向数组的指针，又被称之为行指针，指向一个而数组的一行，如果是一维数组，指向该数组的一整行元素，通过解引用后可以直接当作原数组使用。 123int (*p)[30];int a[30];p = a; 1234int a[3][4];int (*p)[4];p = a;p = a + 1; 行指针也可以取二维数组的某一行。 2 动态分配一维数组123int *a;// malloc 分配地址，内部数据随机a = (int*)malloc(n, sizeof(int)); 二维数组123456int** a;// calloc 分配地址，内部数据清零// 分配a[n][m]a = (int**)calloc(n, sizeof(int*));for (int i = 0; i &lt; n; i++) a[i] = (int*) calloc(m, sizeof(int)); 会发现一个现象，如果给二维数组分配内存，会多占用n个地址。 因为第一次分配指针的指针的地址，会占用一个长度为n的空间，内部存放指针，每个指针指向另外m个区域。 因此一共其实占用了n * m + n 个地址。 3 函数指针函数指针应用，回调函数，将函数指针作为参数传入函数中。 1234567int F(int a, int b) { return a + b;}void solve(int (*p)(int, int)) { //bababbab....} 4 内存分配一个程序占用的内存被划分为Stack, Heap, Code(Text), Static/Global, 在函数中的局部变量会存储在栈中，如果是动态内存分配的空间，会在Heap中开辟，通过一个局部变量指针指向，如果指针被销毁，那么这一片内存没有被释放，就会产生内存泄露。","link":"/2021/01/10/Something-about-Pointers/"},{"title":"[CSAPP] Bits, Bytes And Integers","text":"Tom read again. 1 Shift Operations1.1 Left Shift x &lt;&lt; yLeft Shift the number. Fill with zero on right And throw the extra bits on left. 1.2 Right Shift x &gt;&gt; yThere are 2 kinds of Right Shifting. Logical shift: Just shift right and fill zero on left. Arithmetic shift: Fill the MSB on the left. Why Arithmetic shift ?It’s a little trick. In Two’s Complement Number, the Negative number’s MSB is 1, if you add any bits on left, the value is same to the original. eg: 1234Suppose the MSB is sign bit.0b11011 =&gt; -5add a new bit on left:0b111011 =&gt; -5 So u can suppose the number is negative if the higher bits filled with 1. 1.3 Shift Or Modular operationLeft Shifting a number with k bits width is as same as modular with $2^k$。 2 Numeric Ranges2.1 Unsigned Number$$UMin = {0…0}\\\\UMax = {1…1}\\\\$$ $$\\text {Range from 0 to } 2^k-1$$ 2.2 Two’s Complement Values$$TMin = {100…00} \\\\TMax = {011…00}\\\\$$ $$\\text {Range from } -2^{k-1} \\text{ to } 2^{k-1}-1$$ Some trick If you replace the sign bit in a two’s Complement values with 0, it become a positive number. This positive number adds the abs of the original number will get the $2^{k-1}$. 2.3 Cast between unsigned number and signed numberU can cast them explicitly or implicitly. If both of them in the same expression, the result will cast to unsigned number implicitly. Such as sizeof, the result of sizeof is Unsigned number. So something will go wrong. 1234int i;for (i = 10; sizeof(A) &gt;= 0; i--) { // This loop will go forever as unsigned number is always greater than 0.} 2.3.1 Casting And ComparingWhen Comparing, signed number values implicitly cast to unsigned. Signed Number Unsigned Number Relation -1 0U &gt; -2147483648 = 10…000 2147483647U = 0111…111 &gt; 3 Addition Minus Multiply And Divide3.1 Addition3.1.1 Signed NumberTwo’s Complement Values’ addition can present addition and minus,. When you add two Ts, you may drop the Carry number which also means you operate the modular with $2^k$. eg: Two’s Complement Values: 1101 =&gt; -3 0101 =&gt; 5 add them: 1_0010 =&gt; drop the carry 1, result is 2. But if you see them as Unsigned number, this is 13(0b1101) + 5(0b0101) = 18 % ($2^4$) = 2 3.1.2 TAdd Overflow 3.1.2 Unsigned NumberJust drop the carry. 3.1.3 Multiply $2^k$ or divide itmultiply is left right shift k bits. divide is right shift k bits. 4 Memory4.1 Word SizeThere is no a accurate definition for word size. Word size present the number of bytes processed once. Why 32-bits machine only support 4GB RAM? 32-bits is also the bit number of address, so the address is most 4,294,967,295 which is about 4GB. But 64bits is much longer, which can present more address. 4.2 How is data stored in the memory?Big-endian And Little-endian, Most machine use Little endian. Little-endian means place the lower bytes in the higher bits. Such as…","link":"/2021/01/10/CSAPP-Bits-Bytes-And-Integers-1/"},{"title":"Diary-02-10-2021","text":"年底 昨晚睡觉又梦见以前的人了 家里网络不是很好 课题很难开展，论文写不出来，没什么想法，前面想的idea被英伟达的大佬做了 有点烦 被催着复习考研 富婆我不想努力啦 QWQ","link":"/2021/02/10/Diary-02-10-2021/"}],"tags":[{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"Linear Algebra","slug":"Linear-Algebra","link":"/tags/Linear-Algebra/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/tags/Machine-Learning/"},{"name":"Entropy","slug":"Entropy","link":"/tags/Entropy/"},{"name":"Deep Learning","slug":"Deep-Learning","link":"/tags/Deep-Learning/"},{"name":"diary","slug":"diary","link":"/tags/diary/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Pointers","slug":"Pointers","link":"/tags/Pointers/"},{"name":"CSAPP","slug":"CSAPP","link":"/tags/CSAPP/"}],"categories":[]}